#pragma once

#include <array>
#include <cstdint>
#include <future>
#include <string>
#include <vector>

#include "ConnectedVehicle.h"
#include "Schedule.h"
#include "Config.h"
#include "Mib.h"
#include "Signal.h"
#include "COP_DUAL_RING.h"

#include "siekdbus.hpp"
#include "udpReceiver.hpp"

namespace WaveApp
{
namespace Mmitss
{

class MmitssSignalControlApp;

class MmitssSignalControl
{
  public:
    using ScheduleList = std::vector<Schedule>;
    using ConnectedVehicleList = std::vector<ConnectedVehicle>;

    MmitssSignalControl(MmitssSignalControlApp& parent);
    virtual ~MmitssSignalControl() = default;
    MmitssSignalControl(const MmitssSignalControl&) = delete;
    MmitssSignalControl& operator=(const MmitssSignalControl&) = delete;

    virtual bool onStartup();
    virtual void onShutdown();
    virtual void onExit();
    void tick();

    bool mmitssInit();

  private:
    static constexpr const uint32_t DEFAULT_TIMER_DELAY_MS = 500;

    bool loadMmitssConfig();
    void onTimer(siekdbus::timerid_t id);

    void requestTrajectory();
    void resetArrivalTableInDb();
    void storeArrivalTableInDb();

    void Construct_eventlist();
    void Pack_Event_List(uint8_t* tmp_event_data, int& size);

    void onCriticalPointsReceive(const void* data, size_t len);
    void onTrajectoryReceive(const void* data, size_t len);

    void Find_Passed_Phase_In_Same_Barrier();
    int ConflictCall();
    void UnpackTrajData1(const char* ablob);
    int CheckConflict();
    void ModifyCurPhase();
    void Complete_Barrier();

    // Config
    bool ReadSignalParameters();
    bool get_lane_no();

    MmitssSignalControlApp& m_parent;

    uint32_t m_timerInterval{DEFAULT_TIMER_DELAY_MS};
    siekdbus::timerid_t m_timerId{0};
    siekdbus::TimerConn m_timerConn;

    UdpReceiver m_criticalPointsReceiver;
    UdpReceiver m_trajectoryReceiver;

    std::string m_testSystemAddr;

    // MMITSS members

    ConnectedVehicleList m_trackedVeh;
    ConnectedVehicleList m_vehListEachPhase;

    ScheduleList m_eventListR1;
    ScheduleList m_eventListR2;

    // occupancy value of the detector at stop bar (using as the system detector)
    std::vector<int> m_occupancy;
    // Parameters for trajectory control
    // maximum planning time horizon * number of phases
    std::array<std::array<int, 8>, 131> m_arrivalTable;
    // previous phases of the two rings, either one ring advanced,
    // the previous_phases need to be updated,used to calculate passed phases. [1-8]
    int m_previousPhase[2]{};
    // passed phase in the same ring, [0-7];
    int m_passedPhase[2]{};
    // if no vehicle arrives for a phase, then this phase can be skipped.
    int m_skipPhase[8]{};
    // timer to hold the phase;
    int m_holdTimer{0};
    // this is the time point (at the time point left turn green turns to yellow)
    // to check the ped signal state;
    // only applies to leading left turn, when ped button is pushed when left turn is on
    int m_check_TimePoint{99999};

    // current time
    int m_currentTime{0};
    // the optimal signal plan of 3 barriers generated by DUAL RING COP
    std::array<std::array<int, 4>, 2> m_optSigPlan;
    // the optimal signal sequence of 3 barriers generated by DUAL RING COP
    std::array<std::array<int, 4>, 2> m_optSigSeq;

    // Parameters for EVLS
    float m_penetrationRate{1.0};
    float m_dsrcRange{300};
    // value would be {1,3,4}

    int m_phaseNum{};
    int m_phaseSeq[8]{};

    std::array<int, 8> m_minGreen;
    std::array<int, 8> m_maxGreen;
    std::array<int, 8> m_yellow;
    std::array<int, 8> m_red;
    std::array<int, 8> m_pedWalk;
    std::array<int, 8> m_pedClr;
    // Whether there is a ped call or ped phase is on
    // 0: on call and all phase is off 1: yes

    int m_pedStatus{};
    //[0]: ped status, [1]: ped call in integer number;
    // int                             m_pedInfo[2] {};
    // Which ped phase need to be considered in the COP, 1:yes, 0: no;
    // int                             m_pedPhaseConsidered[8] {};

    // 0 if left turn phases have queuing vehicle <10; 1 if else
    // This flag is used to prevent queue spill back from left turn bay.
    int m_queueWarningP1{};
    int m_queueWarningP5{};

    int m_initPhase[2]{};
    int m_currPhase[2]{};
    double m_InitTime[2]{};
    double m_grnElapse[2]{};
    // Red elapse time of each phase
    std::array<double, 8> m_redElapseTime;
    // Type of objective function that used in COP; 0= total delay 1=average vehicle delay
    int m_delayType{};
    // This is the number of lanes of each phase, this determines discharging rate
    std::array<int, 8> m_laneNo;

    // int rolling_horizon;  //every 7 seconds, solve COP
    int m_beginTime{};

    int m_controlTimer{};
    // used to switch between solving COP and control the signal
    int m_controlFlag{};
    // Whether there is a vehicle coming from the conflict phase
    int m_conflictFlag{};

    // Record current red elapse time information
    // Notes: since COP always runs at the beginning of the green time
    // (2 phases), actually we should calculate the duration of previous
    // red phase for the queue length estimation for the 2 phases just
    // turned red, the red duration time could be 0 (or in actually
    // calculation they are very small)
    // for other four phases, just in the middle of red duration
    double m_redStartTime[8]{};
    int m_previousSignalColor[8]{};

    std::string m_rsuId;
    RsuConfig m_cfg;
    Phase m_phases;
    MmitssMib m_mib;

    bool m_started{false};

    std::future<bool> m_delayedInit;
    CopDualRing m_cop;

    // for requesting trajectory data
    int m_sockfd{-1};
    struct sockaddr_in m_recvAddr;
    uint32_t m_reqCount{0};
    uint32_t m_lastAckCount{0};

    friend CopDualRing;
};

} // namespace Mmitss
} // namespace WaveApp
